#include "bytecode_compiler.hh"

namespace Tailslide {

inline int32_t calculate_jump_operand(uint32_t operand_pos, uint32_t target_pos) {
  return (int32_t)(target_pos - (operand_pos + sizeof(uint32_t)));
}

/// patches bytecode generated by control flow statements to jump to the correct target
/// when the target's offset is not known ahead of time
class LSOStructuredJumpPatcher {
  public:
    explicit LSOStructuredJumpPatcher(LSOBitStream &bstream) :
        _mBS(bstream), _mSourcePos(bstream.pos()) {};
    /// mark where the jump is to
    void markTarget() { _mTargetPos = _mBS.pos(); };
    /// patch the jump operand to jump to the target position
    void patch() {
      if (_mTargetPos == -1)
        markTarget();

      ScopedBitStreamSeek seek(_mBS, _mSourcePos);
      _mBS << calculate_jump_operand(_mSourcePos, (uint32_t)_mTargetPos);
    }
  protected:
    LSOBitStream &_mBS;
    uint32_t _mSourcePos;
    int64_t _mTargetPos = -1;
};



void LSOBytecodeCompiler::buildFunction(LSLASTNode *func) {
  auto *sym = func->getSymbol();
  _mFuncSymData = &_mSymData[sym];

  visitChildren(func);

  for (auto &jump_pair : _mJumpMap) {
    // Seek back to where the jump operand starts
    ScopedBitStreamSeek seek(mCodeBS, jump_pair.second);
    auto label_pos = _mLabelMap[jump_pair.first];
    // Write in the jump target relative to the end of the 32-bit operand
    mCodeBS << calculate_jump_operand(jump_pair.second, label_pos);
  }

  if (!sym->getAllPathsReturn()) {
    writeReturn();
  }
}

bool LSOBytecodeCompiler::visit(LSLEventHandler *handler) {
  buildFunction(handler);
  return false;
}

bool LSOBytecodeCompiler::visit(LSLGlobalFunction *glob_func) {
  buildFunction(glob_func);
  return false;
}

bool LSOBytecodeCompiler::visit(LSLConstantExpression *constant_expr) {
  pushConstant(constant_expr->getConstantValue());
  return false;
}

bool LSOBytecodeCompiler::visit(LSLVectorExpression *vec_expr) {
  // the children just get pushed as floats from left to right,
  // so we can use the base child visitation logic.
  return true;
}

bool LSOBytecodeCompiler::visit(LSLQuaternionExpression *quat_expr) {
  // same as above
  return true;
}

bool LSOBytecodeCompiler::visit(LSLListExpression *list_expr) {
  uint32_t num_children = 0;
  for (auto *child : *list_expr) {
    child->visit(this);
    mCodeBS << LOPC_PUSHARGB << child->getIType();
    ++num_children;
  }
  mCodeBS << LOPC_STACKTOL << num_children;
  return false;
}

bool LSOBytecodeCompiler::visit(LSLUnaryExpression *unary_expr) {
  LSLOperator op = unary_expr->getOperation();
  auto *expr = unary_expr->getChildExpr();
  auto expr_itype = expr->getIType();

  expr->visit(this);
  switch(op) {
    case '-': mCodeBS << LOPC_NEG << expr_itype; break;
    // integer-only, doesn't take a type.
    case '!': mCodeBS << LOPC_BOOLNOT; break;
    case '~': mCodeBS << LOPC_BITNOT; break;
    case OP_POST_DECR:
    case OP_POST_INCR:
      // Push the representation of "1" for the given type
      pushConstant(expr->getType()->getOneValue());
      // need to push another copy onto the stack so we can keep the original
      expr->visit(this);
      if (op == OP_POST_INCR)
        mCodeBS << LOPC_ADD;
      else
        mCodeBS << LOPC_SUB;
      mCodeBS << pack_lso_types(expr_itype, expr_itype);
      storeStackToLValue((LSLLValueExpression *) expr);
      // pop the mutated lvalue off the stack, old lvalue should now be on top.
      mCodeBS << LSO_TYPE_POP_OPCODE[expr_itype];
    default:
      return false;
  }
  return false;
}

static LSLExpression *strip_string_key_autocast(LSLExpression *expr) {
  if (expr->getNodeSubType() == NODE_TYPECAST_EXPRESSION) {
    auto *cast_expr = (LSLTypecastExpression *) expr;
    auto cast_type = cast_expr->getIType();
    // This is a key<->string auto-cast added by the de-sugaring step
    if (cast_expr->getSynthesized() && (cast_type == LST_KEY || cast_type == LST_STRING)) {
      return cast_expr->getChildExpr();
    }
  }
  return expr;
}

bool LSOBytecodeCompiler::visit(LSLBinaryExpression *bin_expr) {
  LSLOperator op = bin_expr->getOperation();
  auto *lhs = bin_expr->getLHS();
  auto *rhs = bin_expr->getRHS();
  auto lhs_type = lhs->getIType();
  auto rhs_type = rhs->getIType();
  auto packed_types = pack_lso_types(lhs_type, rhs_type);
  if (op == '=') {
    // no string<->key auto-cast in assignment context! Doesn't really matter
    // since they both use LOPC_STORES anyways.
    // TODO: is this the case anywhere else?
    rhs = strip_string_key_autocast(rhs);
    rhs->visit(this);
    storeStackToLValue((LSLLValueExpression *) lhs);
    return false;
  } else if (op == OP_MUL_ASSIGN) {
    // Must be that pesky `int *= float` which we can't decouple. Replicate the broken behavior.
    rhs->visit(this);
    lhs->visit(this);
    mCodeBS << LOPC_MUL << pack_lso_types(LST_FLOATINGPOINT, LST_FLOATINGPOINT);
    storeStackToLValue((LSLLValueExpression *) lhs);
    return false;
  }

  rhs->visit(this);
  lhs->visit(this);
  switch(op) {
    case '+': mCodeBS << LOPC_ADD << packed_types; break;
    case '-': mCodeBS << LOPC_SUB << packed_types; break;
    case '*': mCodeBS << LOPC_MUL << packed_types; break;
    case '/': mCodeBS << LOPC_DIV << packed_types; break;
    case '%': mCodeBS << LOPC_MOD << packed_types; break;
    case OP_EQ:  mCodeBS << LOPC_EQ << packed_types;  break;
    case OP_NEQ: mCodeBS << LOPC_NEQ << packed_types; break;
    case OP_GEQ: mCodeBS << LOPC_GEQ << packed_types; break;
    case OP_LEQ: mCodeBS << LOPC_LEQ << packed_types; break;
    case '<': mCodeBS << LOPC_LESS << packed_types; break;
    case '>': mCodeBS << LOPC_GREATER << packed_types; break;
    // these have no type argument since they only work on ints
    case '|': mCodeBS << LOPC_BITOR; break;
    case '&': mCodeBS << LOPC_BITAND; break;
    case '^': mCodeBS << LOPC_BITXOR; break;
    case OP_SHIFT_LEFT: mCodeBS << LOPC_SHL; break;
    case OP_SHIFT_RIGHT: mCodeBS << LOPC_SHR; break;
    case OP_BOOLEAN_AND: mCodeBS << LOPC_BOOLAND; break;
    case OP_BOOLEAN_OR: mCodeBS << LOPC_BOOLOR; break;
    default:
      break;
  }
  return false;
}

bool LSOBytecodeCompiler::visit(LSLLValueExpression *lvalue) {
  if (lvalue->getSymbol()->getSubType() == SYM_GLOBAL) {
    switch(lvalue->getIType()) {
      case LST_INTEGER:
      case LST_FLOATINGPOINT:
        mCodeBS << LOPC_PUSHG;
        break;
      case LST_STRING:
      case LST_KEY:
        mCodeBS << LOPC_PUSHGS;
        break;
      case LST_VECTOR:
        mCodeBS << LOPC_PUSHGV;
        break;
      case LST_QUATERNION:
        mCodeBS << LOPC_PUSHGQ;
        break;
      case LST_LIST:
        mCodeBS << LOPC_PUSHGL;
        break;
      case LST_ERROR:
      case LST_MAX:
      case LST_NULL:
        return false;
    }
  } else {
    switch(lvalue->getIType()) {
      case LST_INTEGER:
      case LST_FLOATINGPOINT:
        mCodeBS << LOPC_PUSH;
        break;
      case LST_STRING:
      case LST_KEY:
        mCodeBS << LOPC_PUSHS;
        break;
      case LST_VECTOR:
        mCodeBS << LOPC_PUSHV;
        break;
      case LST_QUATERNION:
        mCodeBS << LOPC_PUSHQ;
        break;
      case LST_LIST:
        mCodeBS << LOPC_PUSHL;
        break;
      case LST_ERROR:
      case LST_MAX:
      case LST_NULL:
        return false;
    }
  }
  mCodeBS << calculateLValueOffset(lvalue);
  return false;
}

bool LSOBytecodeCompiler::visit(LSLTypecastExpression *cast_expr) {
  auto *expr = cast_expr->getChildExpr();
  expr->visit(this);
  mCodeBS << LOPC_CAST << pack_lso_types(expr->getIType(), cast_expr->getIType());
  return false;
}

bool LSOBytecodeCompiler::visit(LSLPrintExpression *print_expr) {
  auto *expr = print_expr->getChildExpr();
  expr->visit(this);
  mCodeBS << LOPC_PRINT << expr->getIType();
  return false;
}

bool LSOBytecodeCompiler::visit(LSLFunctionExpression *func_expr) {
  auto *func_sym = func_expr->getSymbol();
  auto &func_sym_data = _mSymData[func_sym];

  // need to push empty space onto the stack for the callee to write in the retval
  switch(func_sym->getIType()) {
    // most only need 4 bytes of space
    case LST_INTEGER:
    case LST_FLOATINGPOINT:
    case LST_STRING:
    case LST_KEY:
    case LST_LIST:
      mCodeBS << LOPC_PUSHE;
      break;
    case LST_VECTOR:
      mCodeBS << LOPC_PUSHEV;
      break;
    case LST_QUATERNION:
      mCodeBS << LOPC_PUSHEQ;
      break;
    // void and friends need no space for a retval.
    default:
      break;
  }
  // TODO: what's this empty for?
  mCodeBS << LOPC_PUSHE;
  // keep old base pointer on stack so caller can pop it on return
  mCodeBS << LOPC_PUSHBP;
  // push the arguments onto the stack
  for (auto *child_expr : *func_expr->getArguments()) {
    child_expr->visit(this);
  }
  // make space for locals
  mCodeBS << LOPC_PUSHARGE << (func_sym_data.size - func_sym_data.offset);
  // calculate and set the new base pointer to locals
  mCodeBS << LOPC_PUSHSP;
  mCodeBS << LOPC_PUSHARGI << func_sym_data.size;
  mCodeBS << LOPC_ADD << pack_lso_types(LST_INTEGER, LST_INTEGER);
  mCodeBS << LOPC_POPBP;
  if (func_sym->getSubType() == SYM_BUILTIN)
    mCodeBS << LOPC_CALLLIB_TWO_BYTE << (uint16_t)func_sym_data.index;
  else
    mCodeBS << LOPC_CALL << (uint32_t)func_sym_data.index;
  return false;
}

bool LSOBytecodeCompiler::visit(LSLExpressionStatement *expr_stmt) {
  auto *expr = expr_stmt->getExpr();
  expr->visit(this);
  if (auto pop_opcode = LSO_TYPE_POP_OPCODE[expr->getIType()])
    mCodeBS << pop_opcode;
  return false;
}

bool LSOBytecodeCompiler::visit(LSLJumpStatement *jump_stmt) {
  mCodeBS << LOPC_JUMP;
  // This intentionally clobbers to match LL's LSO compiler behavior.
  _mJumpMap[jump_stmt->getSymbol()->getName()] = mCodeBS.pos();
  // we don't know where the label is in the bytecode yet, so just put 0
  mCodeBS << (uint32_t)0;
  return false;
}

bool LSOBytecodeCompiler::visit(LSLLabel *label_stmt) {
  // This intentionally clobbers to match LL's LSO compiler behavior.
  _mLabelMap[label_stmt->getSymbol()->getName()] = mCodeBS.pos();
  return false;
}

bool LSOBytecodeCompiler::visit(LSLIfStatement *if_stmt) {
  auto *expr = if_stmt->getCheckExpr();
  auto *false_branch = if_stmt->getFalseBranch();

  expr->visit(this);
  mCodeBS << LOPC_JUMPNIF << expr->getIType();
  LSOStructuredJumpPatcher jump_to_false_patcher(mCodeBS);
  // fill with 0 until we know where the branch ends.
  mCodeBS << (int32_t)0;

  if_stmt->getTrueBranch()->visit(this);

  if (false_branch) {
    // need to jump over the code for the false case after hitting the end of true
    mCodeBS << LOPC_JUMP;
    LSOStructuredJumpPatcher jump_past_false_patcher(mCodeBS);
    mCodeBS << (int32_t)0;

    jump_to_false_patcher.markTarget();
    false_branch->visit(this);
    jump_past_false_patcher.patch();
  } else {
    jump_to_false_patcher.markTarget();
  }

  // go back and write in how to jump over the true branch
  jump_to_false_patcher.patch();
  return false;
}

bool LSOBytecodeCompiler::visit(LSLForStatement *for_stmt) {
  // initializer expressions come first and are run unconditionally
  for(auto *init_expr : *for_stmt->getInitExprs()) {
    init_expr->visit(this);
    // nothing consumes the result of these expressions, pop if applicable.
    if (auto pop_opcode = LSO_TYPE_POP_OPCODE[init_expr->getIType()])
      mCodeBS << pop_opcode;
  }

  // top of the loop has conditional jump to break the loop
  auto check_pos = mCodeBS.pos();
  auto *check_expr = for_stmt->getCheckExpr();
  check_expr->visit(this);
  mCodeBS << LOPC_JUMPNIF << check_expr->getIType();
  LSOStructuredJumpPatcher loop_end_jump(mCodeBS);
  mCodeBS << (int32_t)0;

  // followed by the body
  for_stmt->getBody()->visit(this);

  // followed by the increment expression list
  for (auto *incr_expr : *for_stmt->getIncrExprs()) {
    incr_expr->visit(this);
    if (auto pop_opcode = LSO_TYPE_POP_OPCODE[incr_expr->getIType()])
      mCodeBS << pop_opcode;
  }

  // then the jump back to the check expression at the top
  mCodeBS << LOPC_JUMP << calculate_jump_operand(mCodeBS.pos(), check_pos);

  // go back and add the actual pos of end of the loop to the conditional jump
  loop_end_jump.patch();

  return false;
}

bool LSOBytecodeCompiler::visit(LSLWhileStatement *while_stmt) {
  // top of the loop has conditional jump to break the loop
  auto check_pos = mCodeBS.pos();
  auto *check_expr = while_stmt->getCheckExpr();
  check_expr->visit(this);
  mCodeBS << LOPC_JUMPNIF << check_expr->getIType();
  LSOStructuredJumpPatcher loop_end_jump(mCodeBS);
  mCodeBS << (int32_t)0;

  // followed by the body
  while_stmt->getBody()->visit(this);

  // then the jump back to the check expression at the top
  mCodeBS << LOPC_JUMP << calculate_jump_operand(mCodeBS.pos(), check_pos);

  // go back and add the actual pos of end of the loop to the conditional jump
  loop_end_jump.patch();

  return false;
}

bool LSOBytecodeCompiler::visit(LSLDoStatement *do_stmt) {
  auto start_pos = mCodeBS.pos();
  // body first
  do_stmt->getBody()->visit(this);
  // then evaluate the condition
  auto *check_expr = do_stmt->getCheckExpr();
  check_expr->visit(this);
  // then the conditional jump back to the top of the body
  mCodeBS << LOPC_JUMPIF << check_expr->getIType() << calculate_jump_operand(mCodeBS.pos(), start_pos);
  return false;
}

bool LSOBytecodeCompiler::visit(LSLDeclaration *decl_stmt) {
  auto *init_expr = decl_stmt->getInitializer();
  auto *var_type = decl_stmt->getSymbol()->getType();
  if (init_expr) {
    init_expr->visit(this);
  } else {
    auto *default_type = var_type;
    // This gets pushed as an int in the default case, even though it
    // would normally use pushargf.
    if (default_type->getIType() == LST_FLOATINGPOINT) {
      default_type = TYPE(LST_INTEGER);
    }
    pushConstant(default_type->getDefaultValue());
  }

  // use the appropriate opcode to pop the top of the stack and store into a local offset
  mCodeBS << LSO_TYPE_LOAD_LOCAL_OPCODE[var_type->getIType()] << _mSymData[decl_stmt->getSymbol()].offset;
  return false;
}

bool LSOBytecodeCompiler::visit(LSLReturnStatement *ret_stmt) {
  if (auto *expr = ret_stmt->getExpr()) {
    // To match LL's LSO compiler we need to _not_ auto-cast when the expression
    // is promotable to the return type but not an exact match. Yuck.
    if (expr->getNodeSubType() == NODE_TYPECAST_EXPRESSION) {
      auto *cast_expr = (LSLTypecastExpression *) expr;
      // This was synthesized after parsing
      if (cast_expr->getSynthesized())
        expr = cast_expr->getChildExpr();
    }
    auto var_size = LSO_TYPE_DATA_SIZES[expr->getIType()];
    if (var_size) {
      expr->visit(this);
      // write in the retval above the locals
      int32_t retval_offset = -8 - (int32_t) var_size;
      mCodeBS << LSO_TYPE_LOAD_LOCAL_OPCODE[expr->getIType()] << retval_offset;
    }
  }
  writeReturn();
  return false;
}

bool LSOBytecodeCompiler::visit(LSLStateStatement *state_stmt) {
  popLocals();
  mCodeBS << LOPC_STATE << (uint32_t)_mSymData[state_stmt->getSymbol()].index;
  return false;
}


void LSOBytecodeCompiler::pushConstant(LSLConstant *constant) {
  switch(constant->getIType()) {
    case LST_INTEGER:
      mCodeBS << LOPC_PUSHARGI << ((LSLIntegerConstant *) constant)->getValue();
      break;
    case LST_FLOATINGPOINT:
      mCodeBS << LOPC_PUSHARGF << (F32)((LSLFloatConstant *) constant)->getValue();
      break;
    // will be disambiguated in the list case by PUSH_ARGB below.
    case LST_STRING:
    case LST_KEY: {
      auto *str = ((LSLStringConstant *) constant)->getValue();
      mCodeBS << LOPC_PUSHARGS;
      mCodeBS.writeRawData((uint8_t *)str, (uint32_t)(strlen(str) + 1));
      break;
    }
    case LST_VECTOR:
      mCodeBS << LOPC_PUSHARGV << *((LSLVectorConstant *) constant)->getValue();
      break;
    case LST_QUATERNION:
      mCodeBS << LOPC_PUSHARGQ << *((LSLQuaternionConstant *) constant)->getValue();
      break;
    case LST_LIST: {
      auto *list_cv = (LSLListConstant *)constant;
      for (auto *list_child : *list_cv) {
        // push the constant, then its type so STACKTOL knows what's actually on the stack.
        pushConstant((LSLConstant *)list_child);
        mCodeBS << LOPC_PUSHARGB << list_child->getIType();
      }
      mCodeBS << LOPC_STACKTOL << (uint32_t)list_cv->getLength();
      break;
    }
    case LST_ERROR:
    case LST_MAX:
    case LST_NULL:
      break;
  }
}

void LSOBytecodeCompiler::popLocals() {
  // pop locals in reverse order
  for (auto i = _mFuncSymData->locals.rbegin(); i != _mFuncSymData->locals.rend(); ++i) {
    mCodeBS << LSO_TYPE_POP_OPCODE[*i];
  }
  // then the arguments that're above the locals on the stack
  for (auto i = _mFuncSymData->function_args.rbegin(); i != _mFuncSymData->function_args.rend(); ++i) {
    mCodeBS << LSO_TYPE_POP_OPCODE[*i];
  }
}

void LSOBytecodeCompiler::writeReturn() {
  popLocals();
  mCodeBS << LOPC_RETURN;
}

int32_t LSOBytecodeCompiler::calculateLValueOffset(LSLLValueExpression *lvalue) {
  char accessor;
  auto *sym = lvalue->getSymbol();
  auto &sym_data = _mSymData[sym];
  auto offset = (int32_t)sym_data.offset;

  if (auto *accessor_id = lvalue->getMember())
    accessor = accessor_id->getName()[0];
  else
    return offset;

  int32_t accessor_offset;
  // offsets for locals are relative to the top of the stack, which means that
  // x comes is at 0 even though it's "last" if reading the binary data from left
  // to right.
  switch(accessor) {
    case 'x': accessor_offset = 0; break;
    case 'y': accessor_offset = 4; break;
    case 'z': accessor_offset = 8; break;
    case 's': accessor_offset = 12; break;
    default:
      return offset;
  }
  // Conversely, offsets for globals are relative to the start of the global.
  if (sym->getSubType() == SYM_GLOBAL) {
    // only coordinates with float members can be accessed via accessors.
    accessor_offset = ((int32_t)sym_data.size - (int32_t)sizeof(float) - accessor_offset);
  }
  return offset + accessor_offset;
}

/// Store the top of the stack into an lvalue, leaving the value on the stack
void LSOBytecodeCompiler::storeStackToLValue(LSLLValueExpression *lvalue) {
  if (lvalue->getSymbol()->getSubType() == SYM_GLOBAL) {
    switch(lvalue->getIType()) {
      case LST_INTEGER:
      case LST_FLOATINGPOINT:
        mCodeBS << LOPC_STOREG;
        break;
      case LST_STRING:
      case LST_KEY:
        mCodeBS << LOPC_STOREGS;
        break;
      case LST_VECTOR:
        mCodeBS << LOPC_STOREGV;
        break;
      case LST_QUATERNION:
        mCodeBS << LOPC_STOREGQ;
        break;
      case LST_LIST:
        mCodeBS << LOPC_STOREGL;
        break;
      case LST_ERROR:
      case LST_MAX:
      case LST_NULL:
        return;
    }
  } else {
    switch(lvalue->getIType()) {
      case LST_INTEGER:
      case LST_FLOATINGPOINT:
        mCodeBS << LOPC_STORE;
        break;
      case LST_STRING:
      case LST_KEY:
        mCodeBS << LOPC_STORES;
        break;
      case LST_VECTOR:
        mCodeBS << LOPC_STOREV;
        break;
      case LST_QUATERNION:
        mCodeBS << LOPC_STOREQ;
        break;
      case LST_LIST:
        mCodeBS << LOPC_STOREL;
        break;
      case LST_ERROR:
      case LST_MAX:
      case LST_NULL:
        return;
    }
  }
  mCodeBS << calculateLValueOffset(lvalue);
}

}
